# How would i more typically write this code?
'+'(1, '*'(2, 3))

1 + (2 * 3)

# How could i make this call easier to read?
mean(, TRUE, x = c(1:10, NA))

mean(c(1:10, NA), na.rm = TRUE)

# Function components
# All R functions have three parts:
# the body(), the code inside the function.
# the formals(), the list of arguments.
# the environment(), the map of the location of the function's variables.

f <- function(x) x^2
f

formals(f)
body(f)
environment(f)

# Primitive functions
# Primitive functions, like sum(), call C code directly with .primitive()
# and contain no R code. Therefore their formals(), body(), and
# environment() are all NULL:

sum
formals(sum)
body(sum)
environment(sum)

# What function allows me to tell if an object is a function?
is.function(sum)

# What functions allows me to tell if a function is a primitive function?
is.primitive(sum)

# This code makes a list of all functions in the base package.
objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs)

# Which base function has the most arguments?

m_args <- function(funs){
  vec <- vector(length = length(funs))
  for (i in 1:length(funs)) {
    vec[i] <- length(formals(names(funs[i])))
  }
  names(funs[which(vec == max(vec))])
}

m_args(funs)

# Another way
arg_length <- lapply(funs, function(x)(length(formals(x))))
max_args <- which(arg_length == max(unlist(arg_length)))
names(funs[max_args])

# How many base functions have no arguments? What's special about those functions?
length(which(arg_length == 0))
names(funs[which(arg_length == 0)])

# How could i adapt the code to find all primitive functions?
names(Filter(is.primitive, funs))

# If a name isn't defined inside a function, R will look one level up.
x <- 2
g <- function(){
  y <- 1
  c(x, y)
}

g()
rm(x, g)

# The same rules apply if a function is defined inside another function.
x <- 1
h <- function() {
   y <- 2
   i <- function() {
      z <- 3
      c(x, y, z)
   }
   i()
}

h()
rm(x, h)

# The same rules apply to closures, functions created by other functions.
# The following function, j(), returns a function. What will return this function
# when we call it?

j <- function(x) {
  y <- 2
  function() {
    c(x, y)
  }
}

j(1)

k <- j(1)
k()
rm(j, k)

# Functions vs Variables
# Finding functions works exactly the same way as finding variables.
l <- function(x) x + 1
m <- function() {
  l <- function(x) x * 2
  l(10)
}

m()
rm(l, m)

# If i am using a name in a context where it's obvious that i want a function,
# R will ignore objects that are not functions while it is searching
n <- function(x) x / 2
o <- function() {
  n <- 10
  n(n)
}

o()
rm(n, o)

# A fresh start.................
# Every time a function is called, a new environment is created to host execution.
# exists() returns TRUE if there's a variable of that name, otherwise it returns
# FALSE

j <- function() {
  if (!exists("a")) {
    a <- 1
    
  } else {
    a <- a +1
  }
  a
}

j()
rm(j)

# runif() return random numbers with decimal point

runif(10)
runif(10, min = 1, max = 10)
round(runif(10, 1, 10))
set.seed(100)
round(runif(10, 1, 10))

# What does the following code return? Why? What does each of the three c's mean?
c <- 10
c(c = c)
# The first c() runs the combine function to create a vector with an item named c
# with value 10

# What does the following function return? Make a prediction before running the code
# youeself.
f <- function(x) {
  f <- function(x) {
    f <- function(x) {
      x ^ 2
    }
    f(x) + 1
  }
  f(x) *2
}

f(10)
# The function will go down to the lowest level and find x ^ 2 so f(x) <- 100. Next
# R will arrive at the command f(x) + 1 and get 100 + 1 = 101 and finally multiply
# by two to get 202

