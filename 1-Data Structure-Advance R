# all contents must be of the same type (homogenous) 0r the content can be of
# different types (heterogeneous)

#######   Homogeneous   ########   Heterogeneous   ####
                                                      #
# 1d     Atomic Vector                List            #
# 2d     Matrix                       Data frame      #
# nd     Array                                        #
                                                      #
#######################################################

#####################   Vectors   #####################

# The basic data structure in R is the vector. Vectors come in two flavours:
     # Atomic Vector         # List

# They have three common properties:
     # Type                  # Length                     # Attributes
# What it is.     How many elements it contains       Additional Metadata
  typeof()                 length()                       attributes()

# All elements of an atomic vector must be the same type.
# The elements of a list can have different types.

# is.vector() does not test if an object is a vector. Insted it returns TRUE
# only if the object is a vector with no attributes apart form names.

vec <- c("A" = 1, "B" = 2, "D" = 3)
vec
is.vector(vec)
is.atomic(vec)
attributes(vec)

names(vec) <- NULL
vec
is.vector(vec)
is.atomic(vec)
attributes(vec)

class(vec) <- "Number"
vec
is.vector(vec)
is.atomic(vec)
attributes(vec)

# Use is.atomic() || is.list() to test if an object is actually a vector.
# is.atomic() returns TRUE if an object of an atomic type ("logical",
# "integer", "double or numeric", "character", "complex" and "raw") and NULL. 

vec <- c("A" = 1, "B" = 2, "D" = 3)
typeof(vec)
is.atomic(vec) || is.list(vec)

mat <- matrix(1:20, ncol = 5)
attributes(mat)
typeof(mat)
is.vector(mat)
is.atomic(mat) || is.list(mat)

# There are four common types of atomic vectors:
# Logical      Integer       Double or Numeric       Character

# There are two rare types of atomic vectors:
# Complex      Raw

# Atomic vectors are usually created with c(), short for combine:
double_vector <- c(1, 2.5, 4.5)
typeof(double_vector)

# With the L suffix, i get an integer rathar than double
integer_vector <- c(1L, 4L, 6L)
typeof(integer_vector)

# Use TRUE and FALSE (or T and F) to create logical vectors
logical_vectors <- c(TRUE, FALSE, T, F)
typeof(logical_vectors)

character_vector <- c("These are", "some strings")
typeof(character_vector)

# Atomic vectors are always flat, even if i nest c()'s:
c(1, c(2, c(3, 4)))
# the same as
c(1, 2, 3, 4)

# Missing values are specified with NA, which is a logical vector of length 1.
typeof(NA)
length(NA)

# NA will always be coerced to the correct type if used inside c(), or i can
# create NAs of a specific type with NA_real (a double vector), NA_integer_
# and NA_character_
Missing_value <- c(NA, NA, NA)
Missing_value
typeof(Missing_value)

Missing_value <- c(NA, "B", NA, NA)
Missing_value
typeof(Missing_value)

Missing_value <- c(NA, 6, NA, NA)
Missing_value
typeof(Missing_value)

Missing_value <- c(NA, TRUE, NA, NA)
Missing_value
typeof(Missing_value)

Missing_value <- c(NA, NA_character_, NA)
Missing_value
typeof(Missing_value)

Missing_value <- c(NA, NA_integer_, NA)
Missing_value
typeof(Missing_value)

Missing_value <- c(NA, NA_real_, NA)
Missing_value
typeof(Missing_value)

#####################    Types and Tests    #####################

# Given a vector, i can determine its type with typeof(), or check if it's a
# specific type with an "is" function: 
# is.character()      is.integer()     is.double()     is.logical()
# OR, more generally, is.atomic()
int_var <- c(1L, 6L, 10L)
typeof(int_var)
is.atomic(int_var)

dbl_var <- c(1, 2.5, 4.5)
typeof(dbl_var)
is.atomic(dbl_var)

# is.numeric() is a general test for the "numberliness" of a vector and returns
# TRUE for both integer and double vectors. 
is.numeric(int_var)
is.numeric(dbl_var)
is.numeric("KAMALESH")
is.numeric(TRUE)
is.numeric(sum(TRUE))

# When i attempt to combine different types they will be coerced to the most
# flexible type. Types from least to most flexible are:
# Logical, Integer, Double, Character
str(c(TRUE, 2L))
str(c(TRUE, 2))
str(c(TRUE, "K"))
str(c(TRUE, 10L, 34))
str(c(TRUE, 10L, "K"))
str(c(10L, 35, "40"))

# When a logical vector is coerced to an integer or double, TRUE becomes 1 and
# FALSE becomes 0.
x <- c(c(FALSE , FALSE, TRUE))
as.numeric(x)
as.double(x)
as.integer(x)
as.character(x)
sum(x)
mean(x)

###################   Lists  #####################
#                                                #
###################   Lists  #####################

# Lists are different from atomic vectors because their elements can be of any
# type, including lists. I can construct lists by using list():

x <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))
x
str(x)

# Lists are sometimes called recursive vectors, because a list can contain
# other lists. This makes them fundamentally different from atomic vectors.

x <- list(list(list(list())))
x
str(x)
is.recursive(x)

# c() will combine several lists into one. If given a combination of atomic
# vectors and lists, c() will coerce the vectors to lists before combine them.

x <- list(list(1, 2), c(3, 4))
y <- c(list(1, 2), c(3, 4))

x
y

str(x)
str(y)

# The typeof() a list is list. I can test for a list with is.list() and coerce
# to a list with as.list().

# Lists are used to build up many of the more complicated data structure in R.
# For example, both data frames and linear models object are lists:

is.list(mtcars)
model <- lm(mpg ~ wt, data = mtcars)
is.list(model)

# Find default datasets

library(help = "datasets")
help(package = "datasets")

# I can turn a list into an atomic vector with unlist().
# If the elements of a list have different types, unlist() uses the
# same coercion rules as c().

model <- mtcars
model <- unlist(model)
model <- unlist(model, use.names = FALSE)
model[1:10]
model
